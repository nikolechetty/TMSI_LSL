import numpy as np
import matplotlib.pyplot as plt
import data_processing
import math



# raw_data_20220728-182025
data = np.loadtxt("raw_data/raw_data_20220728-183242")
data_crossed = np.loadtxt("raw_data/timestamp_crossed_data_20220802-164047")
data_timestamps = np.loadtxt("raw_data/timestamp_data_20220802-164047")
gui_data = np.load("../clock_gui/combo_info_20220729-151330.npz")


repitions = gui_data['reps']
print("repitions:", gui_data['reps'])
print('Wt/Dt combos:', gui_data['combos'])

ID = np.log2(gui_data['combos'][:,1]/gui_data['combos'][:,0])
print("ID:",ID)

plt.scatter(gui_data['combos'][:,0], gui_data['combos'][:,1], c=ID, s=35)
plt.title('Levels of difficulty tested')
plt.xlabel('$W_{t}$ - Target Width (ms)')
plt.ylabel('$D{t}$ - Temporal Distance (ms)')
plt.set_cmap('RdYlGn_r')
cbar = plt.colorbar()
cbar.set_label('Index of Difficulty (bits)')
plt.show()


fig,ax = plt.subplots(1)
plt.scatter(ID, np.zeros(np.size(ID)), alpha=0.5)
# Turn off tick labels
ax.set_yticklabels([])
ax.set_yticks([])
plt.title("Index of Difficulty")
plt.xlabel("Index of Difficulty")
plt.show()


# raw_data_20220721-160843 - nikole testing 2 
# raw_data_20220721-150654

# plt.plot(data)
# plt.show()
# print(np.shape(data)[1])

data_new = data[~(data == 0).all(axis=1)]
# print(np.shape(data_new))

x_data = (data_new[:, 6] - data_new[0, 6])/4000

# fig, axs = plt.subplots(np.shape(data_new)[1] - 4, sharex=True) # dont need status or lsl clock
# fig.suptitle('Data Flow')
# axs[1].plot(x_data, data_new[:, 0])
# axs[1].title.set_text('EMG')

# axs[2].title.set_text('Accel')
# # axs[2].plot(x_data, data_new[:, 1])
# # axs[3].plot(x_data, data_new[:, 2])
# axs[2].plot(x_data, data_new[:, 3])

# axs[0].plot(x_data, data_new[:, 4])
# axs[0].title.set_text('Cue')

# plt.setp(axs[0].get_xticklabels(), visible=False)
# plt.setp(axs[1].get_xticklabels(), visible=False)
# plt.setp(axs[2].get_xticklabels(), visible=False)
# plt.setp(axs[3].get_xticklabels(), visible=False)


# fig.show()
# plt.show()

NUM_SAMPLES_BUFFER = 400
FILTER_AFTER_N = 100
BP_LOW_CUTOFF = 20
BP_HIGH_CUTOFF = 500
ORDER = 2
LP_HIGH_CUTOFF = 5

Mvc = 232 
percent_mvc = 0.3
mvc_threshold = percent_mvc*Mvc

process = data_processing.postProcessData(4000, data_new[:,0])
process.processAll(BP_LOW_CUTOFF, BP_HIGH_CUTOFF, LP_HIGH_CUTOFF, ORDER, FILTER_AFTER_N)


def findThresholdCrossing(lpData, threshold):
    threshold_crossings = np.diff(lpData > threshold, prepend=False)
    positive_difference = np.diff(lpData, prepend=0) >= 0 
    threshold_crossings_positive = np.argwhere(np.logical_and(threshold_crossings, positive_difference))[:,0]
    return threshold_crossings_positive

threshold_crossings_up = findThresholdCrossing(process.lpFilteredData, mvc_threshold)

def thresholdCrossed(lpData, threshold):
    threshold_crossings = np.diff(lpData > threshold)
    print("function crossing", threshold_crossings)
    positive_difference = np.diff(lpData) > 0    
    print("funciton difference", positive_difference) 
    thresholdCrossed =  np.any(np.logical_and(threshold_crossings, positive_difference))
    return thresholdCrossed

# crossings = thresholdCrossed(np.array([0,0,0,0,0,0,0]), 1)
# print("coressed?", crossings)

# crossings = thresholdCrossed(np.array([2,2,2,2,2,2,2,2,2]), 1)
# print("coressed 2?", crossings)

# crossings = thresholdCrossed(np.array([0, 0, 0, 1, 1, 1,2,2,2,2,2]), 1)
# print("coressed true?", crossings)

stop_cue = (np.where(np.diff(data_new[:, 4]) == 1)[0])
start_cue = (np.where(np.diff(data_new[:, 4]) == -1)[0])

if stop_cue[0] < start_cue[0]:
    stop_cue = stop_cue[1:]

print("threshold corssing:", threshold_crossings_up)
print("start:", start_cue)
print("stop:", stop_cue)

fig, axs = plt.subplots(2, sharex=True) # dont need status or lsl clock
fig.suptitle('Data Flow')

axs[0].plot(x_data, data_new[:, 0])
axs[0].title.set_text('EMG')

for xc in start_cue:
    axs[1].axvline(x=xc/4000, color='g')
for xc in stop_cue:
    axs[1].axvline(x=xc/4000, color='r')

axs[1].plot(x_data, process.lpFilteredData)
axs[1].title.set_text('Filtered EMG')
axs[1].axhline(y=mvc_threshold, color='darkmagenta')

for ups in threshold_crossings_up:
    axs[1].axvline(x=ups/4000, color='m')

for xc in start_cue:
    axs[1].axvline(x=xc/4000, color='g')
for xc in stop_cue:
    axs[1].axvline(x=xc/4000, color='r')


# axs[2].title.set_text('Accel')
# axs[2].plot(x_data, data_new[:, 3])

# Set common labels
axs[1].set_xlabel('Time (in seconds)')
axs[1].set_ylabel('Amplitude (uV)')
axs[0].set_ylabel('Amplitude (uV)')
plt.show()

plt.setp(axs[0].get_xticklabels(), visible=False)
# plt.setp(axs[1].get_xticklabels(), visible=False)



# Exclude the first pulse - that is ardunio power cycling
start_cue = start_cue[:] # [1:]
stop_cue = stop_cue[:] #[1:]

threshold_closest = np.empty(np.size(start_cue[:]))
threshold_closest[:] = np.nan
correct = np.empty(np.size(start_cue[:]))
###for every value in the strt_cue 
for idx_cue, cue in enumerate(start_cue[:]):

    after_start = start_cue[idx_cue] <= threshold_crossings_up
    before_stop = threshold_crossings_up <= stop_cue[idx_cue]
    # check if there is a value between start_cue and stop cue
    if np.any(np.logical_and(after_start, before_stop)):
        in_target = np.argwhere(np.logical_and(after_start, before_stop))
        closet_value = in_target[0]
        threshold_closest[idx_cue] = threshold_crossings_up[in_target[0]]
        correct[idx_cue] = True
    else:
        # if not - get closet 
        idx = (np.abs(threshold_crossings_up - start_cue[idx_cue])).argmin()

        threshold_closest[idx_cue] = threshold_crossings_up[idx]
        correct[idx_cue] = False
         # get rid of values greater than half the distance between the next cue 

print("closest:", threshold_closest)
print("correctness:", correct)

threshold_distance = threshold_closest - start_cue
print("distance away:", threshold_distance)

plt.hist(threshold_distance/4000, bins=8)
plt.title('Time of "click" from cue onset (all levels)')
plt.xlabel('Time (in seconds)')
plt.ylabel('Occurances')
plt.show()


plt.show()

repitions = 5 ############################################ REMOVE 
level = np.arange(len(correct))//repitions
print('Levels:', level)
performance = np.bincount(level,correct)/np.bincount(level)
print('performance per level:', performance)

# plt.scatter(ID, 1-performance)
# plt.title('Fit')
# plt.xlabel('Index of difficulty (bits)')
# plt.ylabel('Error rate')
# plt.xlim([0, 4])
# plt.ylim([0, 1])


bins = np.linspace(np.min(threshold_distance)/4000, np.max(threshold_distance)/4000, 10)



for lvl in np.unique(level):
    indexes = np.equal(level, lvl)
    plt.hist(threshold_distance[indexes]/4000, bins, alpha=0.5, label = lvl) # change lvl to ID in the future
# pyplot.hist(x, bins, alpha=0.5, label='x')
# pyplot.hist(y, bins, alpha=0.5, label='y')
plt.legend(loc='upper right')
plt.title('Time of "click" from cue onset per level')
plt.xlabel('Time (in seconds)')
plt.ylabel('Occurances')
plt.show()








################ Full preprocessing figure 

# fig, axs = plt.subplots(6, sharex=True) # dont need status or lsl clock
# fig.suptitle('Data Flow')
# axs[0].plot(x_data, data_new[:, 4])
# axs[0].title.set_text('Cue')

# for xc in start_cue:
#     axs[0].axvline(x=xc, color='g')
# for xc in stop_cue:
#     axs[0].axvline(x=xc, color='r')


# axs[1].plot(x_data, data_new[:, 0])
# axs[1].title.set_text('EMG')

# axs[2].plot(x_data, process.bpFilteredData)
# axs[2].title.set_text('BP Filtered EMG')

# axs[3].plot(x_data, process.rectifiedData)
# axs[3].title.set_text('Rectified EMG')

# axs[4].plot(x_data, process.lpFilteredData)
# axs[4].title.set_text('LP Filtered EMG')
# axs[4].axhline(y=mvc_threshold, color='g')

# for ups in threshold_crossings_up:
#     axs[4].axvline(x=ups/4000, color='m')

# for xc in start_cue:
#     axs[4].axvline(x=xc, color='g')
# for xc in stop_cue:
#     axs[4].axvline(x=xc, color='r')

# axs[5].title.set_text('Accel')
# axs[5].plot(x_data, data_new[:, 3])

# print(np.size(process.meanData))
# axs[6].plot(x_data[:np.size(process.meanData)], process.meanData)
# axs[6].title.set_text('Mean EMG')

# plt.show()

# plt.setp(axs[0].get_xticklabels(), visible=False)
# plt.setp(axs[1].get_xticklabels(), visible=False)
# plt.setp(axs[2].get_xticklabels(), visible=False)
# plt.setp(axs[3].get_xticklabels(), visible=False)
# plt.setp(axs[4].get_xticklabels(), visible=False)
# plt.setp(axs[5].get_xticklabels(), visible=False)